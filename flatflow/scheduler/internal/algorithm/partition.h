// Copyright 2024 The FlatFlow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef FLATFLOW_SCHEDULER_INTERNAL_ALGORITHM_PARTITION_H_
#define FLATFLOW_SCHEDULER_INTERNAL_ALGORITHM_PARTITION_H_

#include <algorithm>
#include <cassert>
#include <execution>
#include <iterator>
#include <queue>
#include <span>
#include <type_traits>
#include <utility>
#include <vector>

#include "flatflow/data/internal/types.h"

namespace flatflow {
namespace scheduler {
namespace internal {
namespace algorithm {

namespace {

// Subset<>
//
// Represents a partition generated by the Karmarkar-Karp algorithm.
template <typename Index, typename Size, typename UnaryOp>
  requires(
      flatflow::data::internal::Unsigned<Index> &&
      flatflow::data::internal::Unsigned<Size> &&
      flatflow::data::internal::Numerical<std::invoke_result_t<UnaryOp, Size>>)
class Subset {
 public:
  using key_type = Size;
  using mapped_type = Index;
  using value_type = std::pair<Size, Index>;
  using result_type = std::invoke_result_t<UnaryOp, Size>;

  Subset(const value_type &item, UnaryOp op) {
    sum = op(item.first);
    items = std::vector<value_type>(1, item);
  }

  Subset() = delete;

  Subset(const Subset &other) = default;

  Subset &operator=(const Subset &other) = default;

  Subset(Subset &&other) = default;

  Subset &operator=(Subset &&other) = default;

  inline bool operator<(const Subset &other) const noexcept {
    return sum < other.sum;
  }

  // Subset::Join()
  //
  // Merges the given two partitions.
  inline void Join(const Subset &other) {
    sum += other.sum;
    items.reserve(items.size() + other.items.size());
    items.insert(items.cend(), std::make_move_iterator(other.items.begin()),
                 std::make_move_iterator(other.items.end()));
  }

  result_type sum;
  std::vector<value_type> items;
};

// Solution<>
//
// Represents a partial solution used in the Karmarkar-Karp algorithm.
template <typename Index, typename Size, typename UnaryOp>
  requires(
      flatflow::data::internal::Unsigned<Index> &&
      flatflow::data::internal::Unsigned<Size> &&
      flatflow::data::internal::Numerical<std::invoke_result_t<UnaryOp, Size>>)
class Solution {
 public:
  using key_type = Size;
  using mapped_type = Index;
  using value_type = std::pair<Size, Index>;
  using result_type = std::invoke_result_t<UnaryOp, Size>;

  Solution(std::span<const value_type> items, UnaryOp op) {
    subsets.reserve(items.size());
    for (const auto &item : items) {
      subsets.emplace_back(item, op);
    }
    difference = subsets.back().sum - subsets.front().sum;
  }

  Solution() = delete;

  Solution(const Solution &other) = default;

  Solution &operator=(const Solution &other) = default;

  Solution(Solution &&other) = default;

  Solution &operator=(Solution &&other) = default;

  inline bool operator<(const Solution &other) const noexcept {
    return difference < other.difference;
  }

  // Solution::Combine()
  //
  // Differences the given two solutions by joining the subset with the smallest
  // sum in one with the subset with the largest sum in the other, the subset
  // with the second smallest sum in one with the subset with the second largest
  // sum in the other, and so on.
  void Combine(const Solution &other) {
    #pragma omp parallel for
    for (std::size_t index = 0; index < subsets.size(); ++index) {
      subsets[index].Join(other.subsets[subsets.size() - index - 1]);
    }

    std::sort(std::execution::par, subsets.begin(), subsets.end());
    difference = subsets.back().sum - subsets.front().sum;
  }

  result_type difference;
  std::vector<Subset<mapped_type, key_type, UnaryOp>> subsets;
};

}  // namespace

// KarmarkarKarp()
//
// Partitions the given items using the Balanced Largest Differencing Method
// (BLDM) of Michiels, Aarts, Korst, van Leeuwen and Spieksma from the paper
// `Computer-assisted proof of performance ratios for the Differencing Method
// <https://www.sciencedirect.com/science/article/pii/S1572528611000508>`,
// a variant of LDM for balanced number partitioning with larger cardinalities.
template <typename Index, typename Size, typename UnaryOp>
  requires(
      flatflow::data::internal::Unsigned<Index> &&
      flatflow::data::internal::Unsigned<Size> &&
      flatflow::data::internal::Numerical<std::invoke_result_t<UnaryOp, Size>>)
std::vector<std::pair<std::invoke_result_t<UnaryOp, Size>,
                      std::vector<std::pair<Size, Index>>>>
KarmarkarKarp(const std::vector<std::pair<Size, Index>> &items,
              Index num_micro_batches, UnaryOp op) {
  assert(num_micro_batches != 0);

  const auto stride = static_cast<std::size_t>(num_micro_batches);
  assert(items.size() % stride == 0);

  // Initially, BLDM starts with a sequence of `k` partial solutions, where each
  // partial solution is obtained from the `m` smallest remaining items.
  auto solutions = std::priority_queue<Solution<Index, Size, UnaryOp>>();

  for (std::size_t index = 0; index < items.size(); index += stride) {
    solutions.emplace(std::span(items).subspan(index, stride), op);
  }

  // Next, the algorithm selects two partial solutions from the sequence, for
  // which the difference between the maximum and minimum subset sum is largest.
  // These two solutions are combined into a new partial solution by joining the
  // subset with the smallest sum in one solution with the subset with the
  // largest sum in another solution, the subset with the second smallest sum in
  // one solution with the subset with the second largest sum in another
  // solution, and so on. This process is called differencing the solutions.
  // The combined solution replaces the two solutions in the sequence, and we
  // iterate this differencing operation until only one solution in the sequence
  // remains, which is the balanced solution obtained by BLDM.
  while (1 < solutions.size()) {
    auto solution = solutions.top();
    solutions.pop();

    solution.Combine(solutions.top());
    solutions.pop();

    solutions.emplace(solution);
  }

  auto micro_batches =
      std::vector<std::pair<std::invoke_result_t<UnaryOp, Size>,
                            std::vector<std::pair<Size, Index>>>>();
  micro_batches.reserve(solutions.top().subsets.size());

  for (const auto &subset : solutions.top().subsets) {
    micro_batches.emplace_back(subset.sum, std::move(subset.items));
  }

  return micro_batches;
}

}  // namespace algorithm
}  // namespace internal
}  // namespace scheduler
}  // namespace flatflow

#endif  // FLATFLOW_SCHEDULER_INTERNAL_ALGORITHM_PARTITION_H_
