// Copyright 2024 The FlatFlow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef FLATFLOW_SCHEDULER_INTERNAL_PARTITION_H_
#define FLATFLOW_SCHEDULER_INTERNAL_PARTITION_H_

#include <algorithm>
#include <iterator>
#include <queue>
#include <type_traits>
#include <utility>
#include <vector>

#include "absl/log/check.h"

#include "flatflow/types.h"

namespace flatflow {
namespace internal {

// Subset<>
//
// Represents a partition generated by the balanced largest differencing method.
template <typename T, typename U>
  requires flatflow::arithmetic<T>
class Subset {
 public:
  using first_type = std::remove_cvref_t<T>;
  using second_type = std::remove_cvref_t<U>;
  using reference = typename std::vector<second_type>::reference;
  using const_reference = typename std::vector<second_type>::const_reference;
  using iterator = typename std::vector<second_type>::iterator;
  using const_iterator = typename std::vector<second_type>::const_iterator;
  using size_type = typename std::vector<second_type>::size_type;

  Subset() {}

  Subset(first_type sum, const second_type &item) : sum_(sum) {
    items_.emplace_back(item);
  }

  Subset(first_type sum, second_type &&item) : sum_(sum) {
    items_.emplace_back(std::move(item));
  }

  Subset(first_type sum, const std::vector<second_type> &items)
      : sum_(sum), items_(items) {}

  Subset(first_type sum, std::vector<second_type> &&items)
      : sum_(sum), items_(std::move(items)) {}

  Subset(const Subset &other) = default;

  Subset &operator=(const Subset &other) = default;

  Subset(Subset &&other) = default;

  Subset &operator=(Subset &&other) = default;

  first_type &sum() { return sum_; }

  first_type sum() const { return sum_; }

  std::vector<second_type> &items() { return items_; }

  const std::vector<second_type> &items() const { return items_; }

  bool operator<(const Subset &other) const noexcept {
    return sum_ < other.sum();
  }

  reference operator[](size_type index) { return items_[index]; }

  const_reference operator[](size_type index) const { return items_[index]; }

  iterator begin() { return items_.begin(); }

  const_iterator begin() const { return items_.begin(); }

  const_iterator cbegin() const noexcept { return items_.cbegin(); }

  iterator end() noexcept { return items_.end(); }

  const_iterator end() const noexcept { return items_.end(); }

  const_iterator cend() const noexcept { return items_.cend(); }

  // Subset::Join()
  //
  // Merges the two given partitions.
  void Join(const Subset &other) {
    sum_ += other.sum();
    items_.reserve(items_.size() + other.items().size());
    items_.insert(items_.cend(), std::make_move_iterator(other.begin()),
                  std::make_move_iterator(other.end()));
  }

 protected:
  first_type sum_;
  std::vector<second_type> items_;
};

// Solution<>
//
// Represents a partial solution used in the balanced largest differencing
// method.
template <typename InputIterator, typename Proj, typename Pred>
class Solution {
 public:
  using first_type = std::remove_cvref_t<
      std::invoke_result_t<Pred, std::iter_value_t<InputIterator>>>;
  using second_type = std::remove_cvref_t<
      std::invoke_result_t<Proj, std::iter_value_t<InputIterator>>>;

  Solution() {}

  Solution(InputIterator first, InputIterator last, Pred pred, Proj proj) {
    subsets_.reserve(std::distance(first, last));
    for (; first != last; ++first) {
      subsets_.emplace_back(pred(*first), std::move(proj(*first)));
    }
    difference_ = subsets_.back().sum() - subsets_.front().sum();
  }

  Solution(const Solution &other) = default;

  Solution &operator=(const Solution &other) = default;

  Solution(Solution &&other) = default;

  Solution &operator=(Solution &&other) = default;

  first_type &difference() { return difference_; }

  first_type difference() const { return difference_; }

  std::vector<Subset<first_type, second_type>> &subsets() { return subsets_; }

  const std::vector<Subset<first_type, second_type>> &subsets() const {
    return subsets_;
  }

  bool operator<(const Solution &other) const noexcept {
    return difference_ < other.difference();
  }

  // Solution::Combine()
  //
  // Differences the given two solutions by joining the subset with the smallest
  // sum in one with the subset with the largest sum in the other, the subset
  // with the second smallest sum in one with the subset with the second largest
  // sum in the other, and so on.
  void Combine(const Solution &other) {
    auto first = subsets_.begin();
    auto rfirst = other.subsets().rbegin();

    for (; first != subsets_.end(); ++first, ++rfirst) {
      (*first).Join(*rfirst);
    }

    std::sort(subsets_.begin(), subsets_.end());
    difference_ = subsets_.back().sum() - subsets_.front().sum();
  }

 protected:
  first_type difference_;
  std::vector<Subset<first_type, second_type>> subsets_;
};

// BLDM()
//
// Partitions the given items using the balanced largest differencing method
// (BLDM) from the paper `The Differencing Algorithm LDM for Partitioning:
// A Proof of a Conjecture of Karmarkar and Karp`, a variant of LDM for
// balanced number partitioning with larger cardinalities.
// Please refer to https://www.jstor.org/stable/3690207.
//
// NOTE: Description of the algorithm and the proof of performance ratios are
// provided by Michiels, Aarts, Korst, van Leeuwen and Spieksma from the paper
// `Computer-assisted proof of performance ratios for the Differencing Method`.
// See https://doi.org/10.1016/j.disopt.2011.10.001 for the details.
template <typename InputIterator, typename OutputIterator, typename Proj,
          typename Pred>
OutputIterator BLDM(InputIterator first, InputIterator last,
                    OutputIterator result, Pred pred, Proj proj,
                    std::iter_difference_t<InputIterator> m) {
  const auto n = std::distance(first, last);

  if (n == 0) {
    return result;
  }

  CHECK_NE(m, 0);
  CHECK_EQ(n % m, 0);

  // Initially, BLDM starts with a sequence of `k` partial solutions, where each
  // partial solution is obtained from the `m` smallest remaining items.
  auto solutions = std::priority_queue<Solution<InputIterator, Proj, Pred>>();

  for (std::iter_difference_t<InputIterator> offset = 0; offset < n;
       offset += m) {
    solutions.emplace(std::next(first, offset), std::next(first, offset + m),
                      pred, proj);
  }

  // Next, the algorithm selects two partial solutions from the sequence, for
  // which the difference between the maximum and minimum subset sum is largest.
  // These two solutions are combined into a new partial solution by joining the
  // subset with the smallest sum in one solution with the subset with the
  // largest sum in another solution, the subset with the second smallest sum in
  // one solution with the subset with the second largest sum in another
  // solution, and so on. This process is called differencing the solutions.
  // The combined solution replaces the two solutions in the sequence, and we
  // iterate this differencing operation until only one solution in the sequence
  // remains, which is the balanced solution obtained by BLDM.
  while (1 < solutions.size()) {
    auto solution = solutions.top();
    solutions.pop();

    solution.Combine(solutions.top());
    solutions.pop();

    solutions.emplace(std::move(solution));
  }

  return std::move(solutions.top().subsets().begin(),
                   solutions.top().subsets().end(), result);
}

// Partition()
//
// Reorders the given items in the range [`first`, `last`) into `m` subsets
// where each subset contains items with projection `proj` applied, which are
// evaluated via predicate `pred`. The resulting subsets are stored in an output
// range starting from `result`.
template <typename InputIterator, typename OutputIterator, typename Proj,
          typename Pred>
OutputIterator Partition(InputIterator first, InputIterator last,
                         OutputIterator result, Pred pred, Proj proj,
                         std::iter_difference_t<InputIterator> m) {
  return BLDM(first, last, result, pred, proj, m);
}

}  // namespace internal
}  // namespace flatflow

#endif  // FLATFLOW_SCHEDULER_INTERNAL_PARTITION_H_
